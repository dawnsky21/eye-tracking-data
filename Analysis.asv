%% Eye-tracking 문장 읽기 실험 분석 파이프라인 개요
% 이 파일은 EDF → ASC → MATLAB 분석까지 전체 흐름을 정리한 주석 블록이다.
% 실제 코드는 이 구조를 기준으로 함수/스크립트로 나누어 구현한다.

% 0. 참가자·trial 퀄리티 체크 (요약 지표 계산 후 적용)
%   - 참가자 레벨:
%       - comprehension 질문 정답률이 너무 낮은 참가자 제외 (예: < 75% 등 기준 설정)
%       - 전체 trial 중 tracking 실패(눈 미검출 비율, 비정상적으로 짧은 읽기 등)가
%         일정 비율 이상이면 해당 참가자 제외 후보로 표시
%   - trial 레벨:
%       - 문장 길이에 비해 fixation 수가 비정상적으로 적거나 많은 trial 제외
%       - 문장 시작점/끝점 근처에 시선이 전혀 없는 trial은 “제대로 읽지 않은” trial로 제외
%   - 실제 구현 순서:
%       - 6. word × trial 지표 계산 → summary table 생성 후
%         여기에서 참가자/trial 퀄리티 기준을 적용하는 것이 현실적이다.

% 1. EDF → ASC 변환

% 폴더 및 ASC 파일 경로 설정
baseDir = pwd;
subjDir = '20251028_134927_Pilot3_교수님';
ascFileName = 'PILOT3.asc';
ascFile = fullfile(baseDir, subjDir, ascFileName);

disp(ascFile)   % 실제 경로 확인용
if ~isfile(ascFile)
    error('ASC 파일을 찾을 수 없습니다: %s', ascFile);
end

% --- mainscript 결과(ROI + design 정보) 불러오기 ---
elFile = fullfile(baseDir, subjDir, 'EL_demo.mat');
S = load(elFile);   % 안에 있는 변수 전부 읽기

if ~isfield(S, 'results') || ~isfield(S, 'dp')
    error('EL_demo.mat 안에 results 또는 dp 변수가 없습니다.');
end
results = S.results;
dp      = S.dp;

% --- Main 시트 읽기 (designRow 매핑 + target용) ---
xlsxPath = fullfile(baseDir, 'Experimental stimulus_실험용_수정본6.xlsx');
if ~isfile(xlsxPath)
    error('엑셀 파일을 찾을 수 없습니다: %s', xlsxPath);
end
Tmain = readtable(xlsxPath, 'Sheet','Main', 'TextType','string');

% --- designRow 확보: (1) Final.designRow 있으면 그대로, 없으면 문장 매칭으로 복구 ---
if isfield(S, 'Final') && isfield(S.Final, 'designRow')
    Final     = S.Final;
    designRow = double(Final.designRow);
else
    warning('Final/designRow 없음 → Pilot3 호환 모드: 문장 내용으로 designRow를 복구합니다.');

    nTrials = numel(results.words);
    designRow = zeros(nTrials,1);

    % 1) 엑셀 문장 → 단어 리스트 전처리
    nRows = height(Tmain);
    sentWords = cell(nRows,1);
    for r = 1:nRows
        s = string(Tmain.sentence(r));
        if exist('cleanSentence','file')
            s = cleanSentence(s);
        end
        ws = split(strtrim(s));
        sentWords{r} = string(ws(:));
    end

    % 2) 각 trial의 results.words{t}와 매칭되는 row 찾기
    for t = 1:nTrials
        wTrial = string(results.words{t}(:));
        if isempty(wTrial)
            continue;
        end

        matchIdx = [];
        for r = 1:nRows
            wRow = sentWords{r};
            if numel(wRow) ~= numel(wTrial)
                continue;
            end
            if all(wRow == wTrial)
                matchIdx(end+1) = r; %#ok<AGROW>
            end
        end

        if numel(matchIdx) == 1
            designRow(t) = matchIdx;
        elseif isempty(matchIdx)
            warning('Trial %d: 엑셀 Main에서 매칭 문장을 찾지 못했습니다.', t);
        else
            warning('Trial %d: 엑셀 Main에서 매칭 row가 여러 개(%d개)입니다. 첫 번째만 사용.', ...
                    t, numel(matchIdx));
            designRow(t) = matchIdx(1);
        end
    end
end

% --- designRow 범위 체크 + targetIdxPerTrial 만들기 ---
bad = (designRow < 1) | (designRow > height(Tmain));
if any(bad)
    warning('일부 designRow가 Main 시트 범위를 벗어났습니다(비매칭 trial일 수 있음).');
end

% 1) 엑셀에서 target index 벡터 가져오기
%    네가 보여준 엑셀 헤더가
%    sentence, freq, valence, is_catch, target_word, target_idx
%    였으니까, 우선 target_idx를 찾도록 짜자.
varNameCandidates = {'target_idx','targetIndex','target_idx_','targetPos'};  % 열 이름이 다를 경우 대비
nameIdx = find(ismember(Tmain.Properties.VariableNames, varNameCandidates), 1);

if isempty(nameIdx)
    error('Main 시트에서 target index 변수(target_idx 등)를 찾지 못했습니다.');
end

targetVarName = Tmain.Properties.VariableNames{nameIdx};
tmp = double(Tmain.(targetVarName));   % 엑셀에서 target index 벡터

% 2) NaN은 catch trial로 보고 0으로
tmp(isnan(tmp)) = 0;   % catch trial → 0

% 3) trial별 targetIdxPerTrial 채우기
targetIdxPerTrial = zeros(size(designRow));
valid = designRow >= 1 & designRow <= height(Tmain);
targetIdxPerTrial(valid) = tmp(designRow(valid));

% results.wordRects{t} : 각 trial의 [nWords×4] (L T R B) ROI
% results.words{t}     : 각 trial의 단어 string 리스트(있다면)

% 2. ASC → MATLAB struct (sample + event)
%   → parseAscToStruct 내부에서 sample, fix/sacc/blink, MSG, START/END까지 다 파싱해서
%     subj.sample / subj.event.*에 정리함.
subj = parseAscToStruct(ascFile);

% 2.1 샘플 validity 플래그
subj = addSampleValidity(subj, [0 0 1920 1080], 50);

% 2.2 MSG 기반 trial 경계 정의 및 trial struct 만들기
subj = addTrialsFromMsg(subj);

%% 3. drift 기준점(xTrue, yTrue) 자동 계산 (main trial 첫 단어 평균)

% main trial 인덱스: id가 'TRIALID'로 시작하는 trial만 사용
isMain  = arrayfun(@(tr) startsWith(tr.id, 'TRIALID'), subj.trial);
mainIdx = find(isMain);

nMain = numel(mainIdx);
xList = NaN(nMain,1);
yList = NaN(nMain,1);

for k = 1:nMain
    t = mainIdx(k);               % subj.trial에서의 trial index
    if t > numel(results.wordRects)
        continue;
    end

    rects = results.wordRects{t}; % [nWords×4] (L T R B)
    if isempty(rects)
        continue;
    end

    rect = rects(1,:);            % 첫 단어 ROI [x1 y1 x2 y2]
    xList(k) = mean(rect([1 3])); % (x1+x3)/2
    yList(k) = mean(rect([2 4])); % (y1+y3)/2
end

xTrue = mean(xList, 'omitnan');
yTrue = mean(yList, 'omitnan');

fprintf('Drift 기준점(xTrue, yTrue) = (%.2f, %.2f)\n', xTrue, yTrue);

% 3. 좌표 sanity check 및 drift correction (문장 기준 좌표 보정)
%   % ---- drift correction 적용 ----
% 문장 시작점(첫 단어 or 왼쪽 fixation marker)의 이상적인 좌표를 지정.
% 실험 세팅에 맞게 xTrue/yTrue 바꿔줘야 함.
driftCfg = struct();
driftCfg.xTrue         = xTrue;   
driftCfg.yTrue         = yTrue;   
driftCfg.refEvent      = 'SENTENCE_ONSET';
driftCfg.minFixDur     = 60;      % ms
driftCfg.maxAbsOffsetX = 60;      % 허용 x 오차 (px)
driftCfg.maxAbsOffsetY = 40;      % 허용 y 오차 (px)

subj = applyDriftCorrection(subj, driftCfg);

% 이제 subj.sample.gxCorr / gyCorr, subj.event.fix.xCorr / yCorr,
% subj.trial(t).driftOffset / isBadDrift 등이 채워져 있음.
%
% ---- sanity check (시각 확인) ----
% 몇 개 trial을 골라 raw vs corrected time–gx 플롯을 비교해본다.
trialsToCheck = [1 5 10];   % 보고 싶은 trial 번호로 수정

for ii = 1:numel(trialsToCheck)
    tIdx = trialsToCheck(ii);
    if tIdx > numel(subj.trial)
        continue;
    end

    tr = subj.trial(tIdx);
    sampIdx = tr.sampleIdx;

    tRel = subj.sample.time(sampIdx) - tr.startTime;   % trial 시작 기준 상대 시간
    gxRaw = subj.sample.gx(sampIdx);
    gxCorr = subj.sample.gxCorr(sampIdx);
    gyRaw = subj.sample.gy(sampIdx);
    gyCorr = subj.sample.gyCorr(sampIdx);

    figure;
    subplot(2,1,1);
    plot(tRel, gxRaw, '.-');
    hold on;
    yline(driftCfg.xTrue, 'k--');  % 이상적인 x 위치
    xlabel('Time from trial start (ms)');
    ylabel('gx (raw)');
    title(sprintf('Trial %d - Raw gx', tIdx));

    subplot(2,1,2);
    plot(tRel, gxCorr, '.-');
    hold on;
    yline(driftCfg.xTrue, 'k--');
    xlabel('Time from trial start (ms)');
    ylabel('gx (corrected)');
    title(sprintf('Trial %d - Corrected gx', tIdx));
end

% 추가로, trial별 drift 오프셋 분포를 한 번에 보는 플롯 (요약용)
dx = arrayfun(@(tr) tr.driftOffset(1), subj.trial);
dy = arrayfun(@(tr) tr.driftOffset(2), subj.trial);
badDriftTrials = find([subj.trial.isBadDrift]);

figure;
subplot(1,2,1);
stem(dx, 'filled');
hold on;
yline(driftCfg.maxAbsOffsetX, 'r--');
yline(-driftCfg.maxAbsOffsetX, 'r--');
xlabel('Trial');
ylabel('dx (px)');
title('Drift offset X per trial');

subplot(1,2,2);
stem(dy, 'filled');
hold on;
yline(driftCfg.maxAbsOffsetY, 'r--');
yline(-driftCfg.maxAbsOffsetY, 'r--');
xlabel('Trial');
ylabel('dy (px)');
title('Drift offset Y per trial');

% 4. blink / out-of-range / line 기반 전처리
lineYRange = [500 620];
subj = cleanFixations(subj, [0 0 1920 1080], lineYRange, 50, 70);

% 5. fixation → word ROI 매핑
paddingPx = 2;
subj = mapFixationsToWordROIs(subj, results.wordRects, paddingPx);

% 6. Fixation duration 기반 클리닝
shortThresh = 60;
longThresh  = 1200;
subj = cleanFixationDurations(subj, shortThresh, longThresh);

% 7. word × trial 지표 계산 (FFD, GD, TVT, skip, regressions 등)
wordTbl = makeWordTrialTable(subj, results);

%% 7-B. Landing position 계산 (N 포함 전체 단어 기준)

% 새 변수 추가
wordTbl.landingRaw  = nan(height(wordTbl),1);   % px 단위: xFirst - xLeft
wordTbl.landingNorm = nan(height(wordTbl),1);   % 정규화: (xFirst - xLeft)/width

fix = subj.event.fix;   % drift 보정된 xCorr, yCorr 들어 있음

for i = 1:height(wordTbl)
    tr  = wordTbl.trial(i);    % 이 row가 속한 trial 번호
    idx = wordTbl.wordIdx(i);  % 문장 내 몇 번째 단어인지

    % --- word boundary (ROI) 체크 ---
    if tr < 1 || tr > numel(results.wordRects)
        continue;
    end

    rects = results.wordRects{tr};   % [nWords×4] (L T R B)
    if isempty(rects) || idx > size(rects,1)
        continue;
    end

    xLeft  = rects(idx,1);
    xRight = rects(idx,3);
    width  = xRight - xLeft;
    if width <= 0
        continue;
    end

    % --- 이 trial의 fixation 리스트 ---
    if ~isfield(subj.trial, 'fixIdx') || isempty(subj.trial(tr).fixIdx)
        continue;
    end

    fIdxList = subj.trial(tr).fixIdx;   % 이 trial에 속한 fixation index들
    fList    = fix(fIdxList);          % 해당 fixation struct 배열

    % mapFixationsToWordROIs에서 fix.word 필드가 있다고 가정
    if ~isfield(fList, 'word')
        continue;
    end

    onWord = ([fList.word] == idx);    % 이 단어 위 fixation들
    if ~any(onWord)
        continue;   % 이 단어에 fixation이 없으면 landing = NaN 유지
    end

    % 첫 fixation 선택
    firstIdx = find(onWord, 1, 'first');
    xFirst   = fList(firstIdx).xCorr;  % 보정된 x 좌표

    % --- Landing 계산 ---
    wordTbl.landingRaw(i)  = xFirst - xLeft;
    wordTbl.landingNorm(i) = (xFirst - xLeft) / width;
end

%% === Target(N) / Spillover(N+1) 플래그 추가 ===
wordTbl.isTarget    = false(height(wordTbl),1);
wordTbl.isSpillover = false(height(wordTbl),1);

% wordTbl.trial 번호 = results.words / designRow / targetIdxPerTrial의 trial 인덱스로 가정
trialsWord = unique(wordTbl.trial);

fprintf('[CHECK] nDesign=%d, nTrialsInWordTbl=%d\n', ...
        numel(targetIdxPerTrial), numel(trialsWord));

for ii = 1:numel(trialsWord)
    t = trialsWord(ii);   % 이 trial 번호는 designRow(t), targetIdxPerTrial(t)에 대응

    % 안전 범위 체크
    if t < 1 || t > numel(targetIdxPerTrial)
        continue;
    end

    % 이 trial의 타깃 단어 위치 (엑셀 target_idx 기반)
    tIdx = targetIdxPerTrial(t);
    if tIdx <= 0
        continue; % catch trial 등: target 없음
    end

    % wordTbl에서 이 trial의 row들
    rows = (wordTbl.trial == t);
    pos  = wordTbl.wordIdx(rows);   % 1,2,3,... 단어 위치

    % N / N+1 라벨링
    wordTbl.isTarget(rows)    = (pos == tIdx);
    wordTbl.isSpillover(rows) = (pos == (tIdx + 1));
end

% === 디버깅: 몇 개 trial에서 target 위치 점검 ===
checkTrials = [13];  % 보고 싶은 wordTbl.trial 번호들

for tt = checkTrials
    rows_t = wordTbl(wordTbl.trial == tt, ...
        {'trial','wordIdx','wordStr','isTarget','isSpillover'});
    disp(rows_t)
end

%% 7-C. Go-past time(= regression path duration) 계산: 모든 단어 기준

% goPast: 각 word row마다 go-past time(ms)
wordTbl.goPast = nan(height(wordTbl),1);

fx       = subj.event.fix;
fxWord   = [fx.word]';      % 각 fixation이 속한 word index (0은 어떤 단어에도 속하지 않음)
fxOnset  = [fx.onset]';     % ms 단위 onset
fxOffset = [fx.offset]';    % ms 단위 offset

for i = 1:height(wordTbl)
    tr = wordTbl.trial(i);    % 이 row가 속한 trial 번호
    wi = wordTbl.wordIdx(i);  % 이 trial 내 단어 index (1,2,...)

    % wordIdx가 유효한지 체크
    if isnan(wi) || wi <= 0
        continue;
    end
    if tr < 1 || tr > numel(subj.trial)
        continue;
    end

    % 이 trial의 fixation sequence (global index)
    fixIdx = subj.trial(tr).fixIdx(:);
    fixIdx = fixIdx(fixIdx > 0 & fixIdx <= numel(fxWord));  % 안전 범위

    if isempty(fixIdx)
        continue;
    end

    % 이 trial에서 word wi 위에 있었던 fixation들 (global index)
    onThisWord = fixIdx(fxWord(fixIdx) == wi);
    if isempty(onThisWord)
        % 이 단어를 완전히 skip 했으면 goPast는 NaN 유지
        continue;
    end

    % trial 내에서 "첫 번째로 이 단어에 올라간 fixation"의 위치 찾기
    % 1) trial 순서 내 인덱스 시퀀스
    % 2) 그 중 onThisWord에 해당하는 것들의 trial 내 위치
    [~, locInTrial] = ismember(onThisWord, fixIdx);
    locInTrial(locInTrial == 0) = [];   % 방어적 처리
    if isempty(locInTrial)
        continue;
    end

    firstPosInTrial = min(locInTrial);              % trial 내 index (1,2,...)
    firstFixGlobal  = fixIdx(firstPosInTrial);      % global fixation index
    tStart          = fxOnset(firstFixGlobal);      % go-past 시작 시점(ms)

    % 이제 firstPosInTrial 이후로 진행하면서
    % "처음으로 wordIdx > wi 인 단어"로 이동하는 시점을 찾는다.
    exitPosInTrial = NaN;
    for k = firstPosInTrial+1 : numel(fixIdx)
        fNext  = fixIdx(k);
        wNext  = fxWord(fNext);

        if wNext > wi   % i보다 오른쪽 단어로 이동
            exitPosInTrial = k;
            break;
        end
    end

    if isnan(exitPosInTrial)
        % 오른쪽 단어로 이동하지 않고 trial이 끝난 경우:
        % trial의 마지막 fixation offset까지를 go-past로 본다.
        lastFixGlobal = fixIdx(end);
        tEnd          = fxOffset(lastFixGlobal);
    else
        exitFixGlobal = fixIdx(exitPosInTrial);
        tEnd          = fxOffset(exitFixGlobal);
    end

    % go-past time (ms)
    wordTbl.goPast(i) = tEnd - tStart;
end

% 결과 확인 예시
head(wordTbl)          % 앞 몇 줄 눈으로 확인
tvt = wordTbl.TVT;
fprintf('TVT: n=%d, mean=%.1f, sd=%.1f, min=%.1f, max=%.1f\n', ...
    sum(~isnan(tvt)), mean(tvt,'omitnan'), std(tvt,'omitnan'), ...
    min(tvt,[],'omitnan'), max(tvt,[],'omitnan'));

figure;
histogram(tvt, 20);
xlabel('TVT (ms)'); ylabel('Count');
title('Distribution of TVT');

%   - 전처리된 fixation·word 매핑을 바탕으로, 단어 w에 대해 대표적인 읽기 지표를 계산:
%       - first fixation duration (FFD):
%           → 해당 단어에서 첫 fixation 하나의 duration
%       - gaze duration (GD):
%           → 단어에 처음 진입한 후, 오른쪽으로 벗어날 때까지
%              그 단어 위 fixation duration의 합
%       - total viewing time (TVT):
%           → 모든 pass를 포함한 그 단어 위 fixation duration의 합
%       - skipping probability:
%           → 그 단어에 fixation이 한 번도 없는 trial 비율
%       - refixation probability:
%           → 한 단어에서 fixation이 2번 이상인 trial 비율
%       - regression path duration(= go-past time):
%           → 단어 w에 처음 들어간 순간부터 다시 그 단어 오른쪽으로 넘어갈 때까지
%             (왼쪽으로 회귀(regr.) 포함) 걸린 시간의 합
%
%   - 예시 summary table 스케치:
%       summary = table(subjID, trialID, wordIndex, ...
%                       FFD, GD, TVT, skip, refixProb, ...
%                       'VariableNames', {...});

%% 8. summary 기반 참가자/시험 퀄리티 필터링 및 최종 저장

% ---- 8.0 설정값(원하면 나중에 조정 가능) ----
qcCfg = struct();
qcCfg.maxSkipRate        = 0.70;   % 단어 skip 비율이 70% 넘으면 이상 trial
qcCfg.minReadingTimeMs   = 300;    % 너무 짧은 읽기(문장 전체 TVT < 300ms)는 이상
qcCfg.maxReadingTimeMs   = 8000;   % 너무 긴 읽기(> 8초)는 이상
qcCfg.minComprehension   = 0.75;   % 참가자 정답률 75% 미만이면 제외 후보
qcCfg.minUsableTrialProp = 0.50;   % usable trial 비율이 50% 미만이면 제외 후보

% ---- 8.1 trial-level summary 만들기 (wordTbl + results 기반) ----
trials = unique(wordTbl.trial);
nT = numel(trials);

trialSummary = table( ...
    'Size',[nT 9], ...
    'VariableTypes', {'string','double','double','double','double','double','double','double','logical'}, ...
    'VariableNames', {'subj','trial','nWords','nSkipped','skipRate','readingTimeMs','meanFFD','meanGD','acc'});

for ii = 1:nT
    t = trials(ii);

    % 이 trial의 word-level rows
    rows_t = wordTbl(wordTbl.trial == t, :);

    % 단어 수 / 스킵 수
    nWords   = height(rows_t);
    nSkipped = sum(rows_t.skipped);

    % 문장 전체 TVT = 해당 trial의 모든 단어 TVT 합
    tvtAll   = nansum(rows_t.TVT);

    % FFD / GD 평균 (단어들 중 NaN 아닌 것만)
    meanFFD = nanmean(rows_t.FFD);
    meanGD  = nanmean(rows_t.GD);

    % behavioral accuracy (mainscript results에서 가져오기)
    %   - Practice가 아닌 본 시행 기준: results.acc(i) 가 trial i 정오답 (논리)
    if isfield(results, 'acc') && numel(results.acc) >= t
        acc = logical(results.acc(t));
    else
        acc = true;  % 없으면 true로 두고 나중에 조정
    end

    % subj ID (parseAscToStruct에서 subj.id에 넣어둔 파일명 사용)
    if isfield(subj, 'id')
        sid = string(subj.id);
    else
        sid = "PILOT3";   % fallback
    end

    trialSummary.subj(ii)          = sid;
    trialSummary.trial(ii)         = t;
    trialSummary.nWords(ii)        = nWords;
    trialSummary.nSkipped(ii)      = nSkipped;
    trialSummary.skipRate(ii)      = nSkipped / max(nWords,1);
    trialSummary.readingTimeMs(ii) = tvtAll;       % TVT 기반 읽기시간
    trialSummary.meanFFD(ii)       = meanFFD;
    trialSummary.meanGD(ii)        = meanGD;
    trialSummary.acc(ii)           = acc;
end

% ---- 8.2 trial-level 이상치 플래그 ----
badTrial = false(height(trialSummary),1);

% (1) skip 비율이 너무 높으면 이상 trial
badTrial = badTrial | trialSummary.skipRate > qcCfg.maxSkipRate;

% (2) 읽기 시간이 너무 짧거나 긴 trial
badTrial = badTrial | trialSummary.readingTimeMs < qcCfg.minReadingTimeMs;
badTrial = badTrial | trialSummary.readingTimeMs > qcCfg.maxReadingTimeMs;

% (3) 오답 trial 제외
badTrial = badTrial | ~trialSummary.acc;

trialSummary.badTrial = badTrial;

% ---- 8.3 participant-level 퀄리티 체크 (지금은 한 명 기준) ----
% 정답률 (badTrial 여부와 상관없이 전체 기준)
overallAcc = mean(trialSummary.acc);

% usable trial 비율 (badTrial이 아닌 trial 비율)
usableProp = mean(~trialSummary.badTrial);

badSubj = (overallAcc < qcCfg.minComprehension) || ...
          (usableProp < qcCfg.minUsableTrialProp);

fprintf('Participant %s: acc=%.2f, usableTrialProp=%.2f, badSubj=%d\n', ...
    trialSummary.subj(1), overallAcc, usableProp, badSubj);

% ---- 8.4 최종 clean summary 만들기 ----
if badSubj
    cleanSummary = trialSummary([],:);   % 전부 제외 (빈 table)
    warning('Participant %s flagged as badSubj → cleanSummary is empty.', trialSummary.subj(1));
else
    cleanSummary = trialSummary(~trialSummary.badTrial, :);
end

% ---- 8.5 최종 저장 ----
outFile = fullfile(baseDir, subjDir, 'eyeReading_cleanSummary.mat');
save(outFile, 'cleanSummary', 'trialSummary', 'qcCfg');

fprintf('[SAVE] cleanSummary saved to %s (nTrials=%d, nClean=%d)\n', ...
    outFile, height(trialSummary), height(cleanSummary));

%% A. 한 trial에서 time → word index scanpath 보기
t = 1;   % 보고 싶은 trial 번호

% 1) 이 trial의 word-level 데이터만 추출
rows_t = wordTbl(wordTbl.trial == t, :);

% 2) 이 trial에서 실제로 fixation이 있었던 단어만 골라서,
%    그 단어들의 FFD start time이 있다고 가정 (makeWordTrialTable에서 필요하면 추가 가능)
%    일단은 TVT가 0이 아닌 단어들만 “읽힌 단어”로 간주하고, 
%    가짜 time index를 만든 버전:

readRows = rows_t(~isnan(rows_t.TVT) & rows_t.TVT > 0, :);

if isempty(readRows)
    warning('Trial %d: 읽힌 단어가 없습니다.', t);
else
    figure;
    % x축: 단어 순서대로 가짜 time index (1,2,3,…)
    % y축: wordIdx
    plot(1:height(readRows), readRows.wordIdx, '-o');
    xlabel('Fixation order (approx)');
    ylabel('Word index');
    title(sprintf('Trial %d: approx scanpath (word index)', t));
    grid on;
end

outWordFile = fullfile(baseDir, subjDir, 'wordTbl_PILOT3.mat');
save(outWordFile, 'wordTbl');

% === subj / design 정보도 따로 저장 (Stats용) ===
subjFile = fullfile(baseDir, subjDir, 'subj.mat');
save(subjFile, 'subj', 'designRow', 'Tmain');
fprintf('[SAVE] subj saved to %s\n', subjFile);



